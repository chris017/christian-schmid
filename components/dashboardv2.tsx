"use client";
/**
 * Some of this code was generated by v0 by Vercel.
 * @see https://v0.dev/t/PJm3y9BXTIt
 */
import { Alchemy, Network, AssetTransfersCategory } from "alchemy-sdk";
import Link from "next/link";
import { useWeb3Modal } from "@web3modal/wagmi/react";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { ConnectButton } from "@rainbow-me/rainbowkit";
import { Wallet, CalendarDays, BarChart, ArrowUpRight } from "lucide-react";
import { CardTitle, CardHeader, CardContent, Card } from "@/components/ui/card";
import {
  TableHead,
  TableRow,
  TableHeader,
  TableCell,
  TableBody,
  Table,
} from "@/components/ui/table";
import { useEffect, useState } from "react";
import { useAccount, useBalance } from "wagmi";
import axios from "axios";
import { Mobula } from "mobula-sdk";
import { Order } from "mobula-sdk/dist/sdk/models/operations";
export function Dashboardv2() {
  const [isClient, setIsClient] = useState(false);
  const [totalWalletBalance, setTotalWalletBalance] = useState<string | null>(
    null
  );
  const [transactionHashes, setTransactionHashes] = useState<string[]>([]);
  const [transactionBlock, setTransactionBlock] = useState<string[]>([]);
  const [fromAddress, setFromAddress] = useState<string[]>([]);
  const [toAddress, setToAddress] = useState<string[]>([]);
  const [transactionValue, setTransactionValue] = useState<string[]>([]);

  const { address } = useAccount();

  const alchemyConfig = {
    apiKey: process.env.ALCHEMY_API_KEY,
    network: Network.ETH_MAINNET,
  };
  const alchemy = new Alchemy(alchemyConfig);

  useEffect(() => {
    setIsClient(typeof window !== "undefined"); // Mark the component as client-side rendered
  }, []);

  const walletConnected = address != null;
  const formatAddress = (address: string | null) => {
    if (address === null) {
      return "N/A"; // or any placeholder text you prefer
    }
    return `${address.substring(0, 8)}...${address.substring(
      address.length - 8
    )}`;
  };

  useEffect(() => {
    if (!isClient || !walletConnected) {
      console.log("Wallet not connected");
      return; // Exit the useEffect if the wallet is not connected
    }

    const fetchData = async () => {
      try {
        // Fetch portfolio data
        const portfolioResponse = await fetch(
          `https://api.mobula.io/api/1/wallet/portfolio?blockchains=1&wallet=${address}`
        );
        const portfolioData = await portfolioResponse.json();

        if (
          portfolioData &&
          portfolioData.data &&
          portfolioData.data.total_wallet_balance !== undefined
        ) {
          const formattedBalance = parseFloat(
            portfolioData.data.total_wallet_balance
          ).toFixed(2);
          setTotalWalletBalance(formattedBalance);
        } else {
          // Handle the case where total_wallet_balance is not available
        }
        // Fetch asset transfers
        const assetTransfers = await alchemy.core.getAssetTransfers({
          fromBlock: "0x0",
          toBlock: "latest",
          toAddress: address,
          category: [
            AssetTransfersCategory.EXTERNAL,
            AssetTransfersCategory.ERC20,
            AssetTransfersCategory.ERC721,
            AssetTransfersCategory.ERC1155,
          ],
          maxCount: 0x0A,
        });

        const hashes = assetTransfers.transfers.map((transfer) =>
          transfer.hash.substring(0, 4)
        );
        const block = assetTransfers.transfers.map(
          (transfers) => transfers.blockNum
        );
        const fromAd = assetTransfers.transfers.map((transfer) =>
          formatAddress(transfer.from)
        );
        const toAd = assetTransfers.transfers.map((transfer) =>
          formatAddress(transfer.to)
        );
        const value = assetTransfers.transfers.map((transfer) =>
          transfer.value !== null ? transfer.value.toString() : "N/A"
        );
        setTransactionHashes(hashes);
        setTransactionBlock(block);
        setFromAddress(fromAd);
        setToAddress(toAd);
        setTransactionValue(value);

        // Process the data as needed
      } catch (error) {
        console.error("Fetching error:", error);
        // Handle the fetch error
      }
    };

    fetchData();
  }, [isClient, address, walletConnected]);
  return (
    <div className="flex flex-col h-screen">
      <main className="flex flex-1 flex-col gap-4 p-4 md:gap-8 md:p-10">
        <div className="flex flex-col md:flex-row justify-between items-center">
          <h1 className="text-2xl font-bold py-5">ERC20-Dashboard</h1>
          <ConnectButton
            accountStatus={{
              smallScreen: "address",
              largeScreen: "address",
            }}
            showBalance={{
              smallScreen: false,
              largeScreen: true,
            }}
          />
        </div>
        <div>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2 space-y-0">
              <CardTitle className="text-sm font-medium">
                Wallet Balance
              </CardTitle>
              <Wallet className="w-4 h-4 text-gray-500 dark:text-gray-400" />
            </CardHeader>
            <CardContent>
              {isClient && (
                <div>
                  <div className="text-2xl font-bold">
                    {
                      walletConnected ? `$${totalWalletBalance}` : "0$" // Anzeigen des Beispielwerts, wenn das Wallet nicht verbunden ist
                    }
                  </div>
                </div>
              )}
              <p className="text-xs text-gray-500 dark:text-gray-400">
                Total balance in your wallet
              </p>
            </CardContent>
          </Card>
        </div>
        <div>
          <Card>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[100px]">Transaction</TableHead>
                  <TableHead>Block</TableHead>
                  <TableHead>From</TableHead>
                  <TableHead>To</TableHead>
                  <TableHead>Value</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {walletConnected ? (
                  transactionHashes.length > 0 ? (
                    transactionHashes.map((hash, index) => (
                      <TableRow key={index}>
                        <TableCell className="font-medium">{hash}</TableCell>
                        <TableCell>{transactionBlock[index]}</TableCell>
                        <TableCell>{fromAddress[index]}</TableCell>
                        <TableCell>{toAddress[index]}</TableCell>
                        <TableCell>{transactionValue[index]}</TableCell>
                        {/* Update as needed */}
                      </TableRow>
                    ))
                  ) : (
                    <TableRow>
                      <TableCell colSpan={10}>No transactions found.</TableCell>
                    </TableRow>
                  )
                ) : (
                  <TableRow>
                    <TableCell colSpan={10}>Wallet not connected.</TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </Card>
        </div>
        {/* <w3m-button /> */}
      </main>
    </div>
  );
}
